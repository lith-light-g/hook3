{"version":3,"file":"static/iframe.346fcbd041b7ab8b6d77.bundle.js","sources":["webpack:///./src/components/ChartRunsByFrequency/ChartRunsByFrequency.js"],"sourcesContent":["import { axisBottom, axisLeft } from 'd3-axis';\r\nimport { easeQuadOut } from 'd3-ease';\r\nimport { scaleLinear, scaleQuantize, scaleTime } from 'd3-scale';\r\nimport { select } from 'd3-selection';\r\nimport { transition } from 'd3-transition';\r\nimport dateSubYears from 'date-fns/sub_years';\r\nimport { maxBy, minBy, random, find } from 'lodash-es';\r\nimport PropTypes from 'prop-types';\r\nimport React, { useEffect, useMemo, useRef, useContext } from 'react';\r\nimport styled from 'styled-components';\r\nimport { active, bgSecondary, primary, secondary } from '../colors';\r\nimport useHasElementEntered from '../../hooks/useHasElementEntered';\r\nimport SelectedItemContext from '../../contexts/SelectedItemContext';\r\n\r\nconst Chart = styled.div`\r\n  font-size: 16px;\r\n\r\n  & .x-axis,\r\n  & .y-axis {\r\n    fill: ${bgSecondary};\r\n\r\n    & text {\r\n      font-size: 16px;\r\n      font-family: Acme;\r\n    }\r\n  }\r\n\r\n  & .runs {\r\n    cursor: pointer;\r\n\r\n    & .circle {\r\n      fill: ${secondary};\r\n      stroke: ${primary};\r\n      stroke-width: 1;\r\n      position: relative;\r\n      z-index: 5;\r\n\r\n      &:hover,\r\n      &--selected {\r\n        fill: ${active};\r\n\r\n        + .text {\r\n          visibility: visible;\r\n        }\r\n      }\r\n    }\r\n\r\n    & .text {\r\n      font-family: sans-serif;\r\n      text-anchor: middle;\r\n      fill: ${primary};\r\n      position: relative;\r\n      z-index: 10;\r\n      pointer-events: none;\r\n      visibility: hidden;\r\n    }\r\n  }\r\n`;\r\n\r\nconst ChartRunsByFrequency = ({\r\n  matchingRunsBySegmentGroups,\r\n  matchingRunsByHighestBestEfforts,\r\n  matchingRunsBySegments,\r\n  showSegmentGroupRuns,\r\n  showSegmentRuns,\r\n  showBestEffortRuns,\r\n}) => {\r\n  const margin = { top: 60, right: 60, bottom: 60, left: 60 };\r\n  const width = 800 - margin.left - margin.right;\r\n  const height = 600 - margin.top - margin.bottom;\r\n  const { setSelectedItem, ...selectedItem } = useContext(SelectedItemContext);\r\n  const chart = useRef();\r\n  const hasElementEntered = useHasElementEntered(chart);\r\n  const xScaleRef = useRef();\r\n  const xAxisRef = useRef();\r\n  const yScaleRef = useRef();\r\n  const yAxisRef = useRef();\r\n  const radiusScaleRef = useRef();\r\n  const containerRef = useRef();\r\n  const xAxisContainerRef = useRef();\r\n  const yAxisContainerRef = useRef();\r\n  const runsBySegmentGroupsWithType = useMemo(\r\n    () =>\r\n      showSegmentGroupRuns\r\n        ? matchingRunsBySegmentGroups.map(r => ({\r\n            ...r,\r\n            type: 'SEGMENT_GROUP',\r\n          }))\r\n        : [],\r\n    [matchingRunsBySegmentGroups, showSegmentGroupRuns]\r\n  );\r\n  const runsByHighestBestEffortsWithType = useMemo(\r\n    () =>\r\n      showBestEffortRuns\r\n        ? matchingRunsByHighestBestEfforts.map(r => ({\r\n            ...r,\r\n            type: 'HIGHEST_BEST_EFFORT',\r\n          }))\r\n        : [],\r\n    [matchingRunsByHighestBestEfforts, showBestEffortRuns]\r\n  );\r\n  const runsBySegmentsWithType = useMemo(\r\n    () =>\r\n      showSegmentRuns\r\n        ? matchingRunsBySegments.map(r => ({ ...r, type: 'SEGMENT' }))\r\n        : [],\r\n    [matchingRunsBySegments, showSegmentRuns]\r\n  );\r\n  const allRuns = useMemo(\r\n    () => [\r\n      ...runsByHighestBestEffortsWithType,\r\n      ...runsBySegmentGroupsWithType,\r\n      ...runsBySegmentsWithType,\r\n    ],\r\n    [\r\n      matchingRunsByHighestBestEfforts,\r\n      matchingRunsBySegmentGroups,\r\n      matchingRunsBySegments,\r\n      showBestEffortRuns,\r\n      showSegmentGroupRuns,\r\n      showSegmentRuns,\r\n    ]\r\n  );\r\n\r\n  // SVG creation\r\n  useEffect(\r\n    () => {\r\n      const svg = select(chart.current)\r\n        .append('svg')\r\n        .attr(\r\n          'viewBox',\r\n          `0 0 ${width + margin.left + margin.right} ${height +\r\n            margin.top +\r\n            margin.bottom}`\r\n        );\r\n\r\n      // main container\r\n      const container = svg\r\n        .append('g')\r\n        .attr('class', 'container')\r\n        .attr('transform', `translate(${margin.left}, ${margin.top})`);\r\n      containerRef.current = container;\r\n\r\n      // x-axis container\r\n      xAxisContainerRef.current = container\r\n        .append('g')\r\n        .attr('class', 'x-axis')\r\n        .attr('transform', `translate(0, ${height})`);\r\n\r\n      // y-axis container\r\n      yAxisContainerRef.current = container.append('g').attr('class', 'y-axis');\r\n\r\n      xScaleRef.current = scaleTime().range([0, width]);\r\n      yScaleRef.current = scaleLinear().range([0, height]);\r\n      radiusScaleRef.current = scaleQuantize().range([5, 10, 20, 30, 50]);\r\n      xAxisRef.current = axisBottom(xScaleRef.current);\r\n      yAxisRef.current = axisLeft(yAxisRef.current).ticks(10, '~s');\r\n    },\r\n    [chart]\r\n  );\r\n\r\n  // SVG drawing and updating\r\n  useEffect(\r\n    () => {\r\n      if (hasElementEntered) {\r\n        const xScale = xScaleRef.current;\r\n        const yScale = yScaleRef.current;\r\n        const radiusScale = radiusScaleRef.current;\r\n        const xAxis = xAxisRef.current;\r\n        const yAxis = yAxisRef.current;\r\n        const container = containerRef.current;\r\n        const xAxisContainer = xAxisContainerRef.current;\r\n        const yAxisContainer = yAxisContainerRef.current;\r\n\r\n        if (allRuns.length === 0) {\r\n          const now = Date.now();\r\n          xScale.domain([dateSubYears(now, 1), now]);\r\n          yScale.domain([21097, 0]);\r\n          radiusScale.domain([0, 5]);\r\n        } else {\r\n          xScale.domain([\r\n            minBy(allRuns, ({ date }) => date).date,\r\n            maxBy(allRuns, ({ date }) => date).date,\r\n          ]);\r\n          yScale.domain([\r\n            maxBy(allRuns, ({ distance }) => distance).distance,\r\n            0,\r\n          ]);\r\n          radiusScale.domain([0, maxBy(allRuns, ({ count }) => count).count]);\r\n        }\r\n\r\n        const axisTransition = transition()\r\n          .duration(750)\r\n          .ease(easeQuadOut);\r\n\r\n        xAxis.scale(xScale);\r\n        yAxis.scale(yScale);\r\n\r\n        xAxisContainer.transition(axisTransition).call(xAxis);\r\n\r\n        yAxisContainer.transition(axisTransition).call(yAxis);\r\n\r\n        const update = container.selectAll('g.runs').data(allRuns, d => d.id);\r\n        const enter = update.enter();\r\n        const exit = update.exit();\r\n\r\n        // fade away exit selection\r\n        const t = transition().duration(250);\r\n        exit\r\n          .select('circle')\r\n          .transition(t)\r\n          .attr('r', 0);\r\n        exit\r\n          .transition(t)\r\n          .attr('opacity', 0)\r\n          .remove();\r\n\r\n        // resize update selection\r\n        update\r\n          .select('circle')\r\n          .transition(t)\r\n          .attr('r', d => radiusScale(d.count));\r\n\r\n        // enter selection\r\n        const g = enter\r\n          .append('g')\r\n          .attr('opacity', 1)\r\n          .attr('class', 'runs')\r\n          .on('click', d => {\r\n            switch (d.type) {\r\n              case 'HIGHEST_BEST_EFFORT':\r\n                window.open(`/BestEffort/${d.id}`, '_self');\r\n                break;\r\n              case 'SEGMENT_GROUP':\r\n                window.open(`/SegmentGroup/${d.id}`, '_self');\r\n                break;\r\n              case 'SEGMENT':\r\n                window.open(`/Segment/${d.id}`, '_self');\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          })\r\n          .on('mouseover', setSelectedItem)\r\n          .on('mouseout', () => setSelectedItem());\r\n        g.append('circle')\r\n          .attr('class', 'circle')\r\n          .attr('r', 0)\r\n          .attr('cx', d => xScale(d.date))\r\n          .attr('cy', d => yScale(d.distance))\r\n          .transition(t)\r\n          .delay(() => random(750))\r\n          .attr('r', d => radiusScale(d.count));\r\n        g.append('text')\r\n          .attr('class', 'text')\r\n          .attr('x', d => xScale(d.date))\r\n          .attr('y', d => yScale(d.distance))\r\n          .text(d => d.label);\r\n      }\r\n    },\r\n    [allRuns, chart, hasElementEntered]\r\n  );\r\n\r\n  // selected item\r\n  useEffect(\r\n    () => {\r\n      if (hasElementEntered) {\r\n        const yScale = yScaleRef.current;\r\n        const radiusScale = radiusScaleRef.current;\r\n        const container = containerRef.current;\r\n\r\n        const { type, id } = selectedItem;\r\n        let runsToScan = [];\r\n        switch (type) {\r\n          case 'HIGHEST_BEST_EFFORT':\r\n            runsToScan = runsByHighestBestEffortsWithType;\r\n            break;\r\n          case 'SEGMENT_GROUP':\r\n            runsToScan = runsBySegmentGroupsWithType;\r\n            break;\r\n          case 'SEGMENT':\r\n            runsToScan = runsBySegmentsWithType;\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n        const selectedRun = find(runsToScan, run => run.id === id);\r\n        const t = transition().duration(250);\r\n        const update = container\r\n          .selectAll('g.runs')\r\n          .data(selectedRun ? [selectedRun] : [], d => d.id);\r\n        update.select('.circle').classed('circle--selected', true);\r\n        update\r\n          .select('.text')\r\n          .transition(t)\r\n          .attr('y', d => yScale(d.distance) - radiusScale(d.count) - 5);\r\n\r\n        const exit = update.exit();\r\n        exit.select('.circle').classed('circle--selected', false);\r\n        exit.select('.text').attr('y', d => yScale(d.distance));\r\n      }\r\n    },\r\n    [allRuns, chart, hasElementEntered, selectedItem]\r\n  );\r\n\r\n  return <Chart className=\"ChartRunsByFrequency\" ref={chart} />;\r\n};\r\n\r\nChartRunsByFrequency.defaultProps = {\r\n  matchingRunsPerSegmentGroups: [],\r\n  matchingRunsByHighestBestEfforts: [],\r\n  matchingRunsPerSegments: [],\r\n  showBestEffortRuns: false,\r\n  showSegmentGroupRuns: false,\r\n  showSegmentRuns: false,\r\n};\r\n\r\nChartRunsByFrequency.propTypes = {\r\n  matchingRunsBySegmentGroups: PropTypes.arrayOf(\r\n    PropTypes.shape({\r\n      id: PropTypes.number,\r\n      count: PropTypes.number,\r\n      label: PropTypes.string,\r\n      distance: PropTypes.number,\r\n      date: PropTypes.instanceOf(Date),\r\n    })\r\n  ),\r\n  matchingRunsByHighestBestEfforts: PropTypes.arrayOf(\r\n    PropTypes.shape({\r\n      id: PropTypes.number,\r\n      count: PropTypes.number,\r\n      label: PropTypes.string,\r\n      distance: PropTypes.number,\r\n      date: PropTypes.instanceOf(Date),\r\n    })\r\n  ),\r\n  matchingRunsBySegments: PropTypes.arrayOf(\r\n    PropTypes.shape({\r\n      id: PropTypes.number,\r\n      count: PropTypes.number,\r\n      label: PropTypes.string,\r\n      distance: PropTypes.number,\r\n      date: PropTypes.instanceOf(Date),\r\n    })\r\n  ),\r\n  showBestEffortRuns: PropTypes.bool,\r\n  showSegmentGroupRuns: PropTypes.bool,\r\n  showSegmentRuns: PropTypes.bool,\r\n};\r\n\r\nexport default ChartRunsByFrequency;\r\n"],"mappings":"AAcA","sourceRoot":""}